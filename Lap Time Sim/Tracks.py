from re import X #wtf is this...
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
import ezdxf #module for reading and writing dxfs for track layouts
from scipy.interpolate import interp1d
import scipy.optimize as opt
import CarData

from Parameters import motors_list, I_rms

'''Simulation functions'''

def write_track():
    doc = ezdxf.new()
    msp = doc.modelspace()
    msp.add_arc((-30,0),30,0,180)
    msp.add_line((-60,0),(-60,-75))
    msp.add_arc((-52.5,-75),7.5,180,0)
    msp.add_arc((-30,-75),15,180,0,False)
    msp.add_arc((-7.5,-75),7.5,180,0)
    msp.add_line((0,-75),(0,0))

    doc.saveas('compound_curves.dxf')

def read_track(filename, reorder=True):
    '''Reads in a track DXF and reorders the entities in the DXF so that it's a continuous path'''
    #Read in file
    import sys
    try:
        doc = ezdxf.readfile(filename)
    except IOError:
        print(f"Not a DXF file or a generic I/O error.")
        sys.exit(1)
    except ezdxf.DXFStructureError:
        print(f"Invalid or corrupted DXF file.")
        sys.exit(2)

    #Iterate through dxf and calculate start and end points for each entity
    entity_list=[e for e in doc.modelspace() if e.dxftype()!='MTEXT'] #MTEXT entities are the "SOLIDWORKS Educational Purposes only" crap in the bottom left corner of DXFs
    
    if reorder:
        start_points=[]
        end_points=[]
        line_index=0
        for i in range(len(entity_list)):
            if entity_list[i].dxftype()=='ARC':
                center = np.array((entity_list[i].dxfattribs()['center'][0],entity_list[i].dxfattribs()['center'][1]))
                r = entity_list[i].dxfattribs()['radius']

                start_points.append(np.array((center[0]+r*np.cos(entity_list[i].dxfattribs()['start_angle']*np.pi/180),center[1]+r*np.sin(entity_list[i].dxfattribs()['start_angle']*np.pi/180))))
                end_points.append(np.array((center[0]+r*np.cos(entity_list[i].dxfattribs()['end_angle']*np.pi/180),center[1]+r*np.sin(entity_list[i].dxfattribs()['end_angle']*np.pi/180))))
            
            elif entity_list[i].dxftype()=='LINE':
                line_index=i

                start_points.append(np.array((entity_list[i].dxfattribs()['start'][0],entity_list[i].dxfattribs()['start'][1])))
                end_points.append(np.array((entity_list[i].dxfattribs()['end'][0],entity_list[i].dxfattribs()['end'][1])))
            else:
                print(entity_list[i].dxftype())
                print(entity_list[i].dxfattribs())
        #print(line_index)
        
        #reorder the dxf
        i = line_index
        correct_order=[line_index]
        reverse=np.zeros(len(entity_list))

        for unused_index in range(len(entity_list)-1):
            delta_start = np.ones(len(entity_list)) #will become list of distance^2 from endpoint of current entity to start points of all others
            delta_end = np.ones(len((entity_list))) #will become list of distance^2 from endpoint of current entity to end points of all others
            
            if reverse[i]:
                end_point = start_points[i%len(entity_list)]
            else:
                end_point = end_points[i%len(entity_list)]
            for j in range(i+1,i+len(start_points)):
                delta_start[j%len(entity_list)] = (start_points[j%len(entity_list)][0] - end_point[0])**2 +(start_points[j%len(entity_list)][1] - end_point[1])**2
                delta_end[j%len(entity_list)] = (end_points[j%len(entity_list)][0] - end_point[0])**2 +(end_points[j%len(entity_list)][1] - end_point[1])**2
            
            if np.min(delta_start) < 0.01:
                correct_order.append(np.argmin(delta_start))
            elif np.min(delta_end) < 0.01:
                correct_order.append(np.argmin(delta_end))
                reverse[np.argmin(delta_end)] = 1
            else:
                print('some ripe bullshit') #happens if the track isn't a loop, otherwise some extremely ripe bs has occured
            i = correct_order[-1]
            

        #print(correct_order)
        #print(reverse)
        reordered_entity_list = np.take(np.array(entity_list),correct_order)
        reordered_reverse= np.take(reverse,correct_order)

        print('Processed {} DXF entities'.format(len(reordered_entity_list)))
        return (reordered_entity_list,  reordered_reverse)
    else:
        return (entity_list, reverse)




def process_track(track_tuple, car, verbose=False):    
    '''Runs a simulation of car around track_tuple, generated by read_track()'''
    #Plotting setup stuff
    if verbose:
        sector_corners = 6 #number of corners in a sector
        fig = plt.figure(figsize=(9,6))
        fig.set_tight_layout(True)
        ax=[]
        ax.append(fig.add_subplot(221))
        ax.append(fig.add_subplot(223))
        ax.append(fig.add_subplot(122))
        def colorplot(ax, x, y, c, cmap_name='turbo', vmin=0, vmax=1):
            '''plot a line on axis ax with colour along line colourmapped to array c'''
            cmap=mpl.colormaps[cmap_name]
            norm = mpl.colors.Normalize(vmin=vmin,vmax=vmax)
            for i in range(len(x)-1):
                ax.plot([x[i],x[i+1]],[y[i],y[i+1]],c=cmap(norm(0.5*(c[i]+c[i+1]))), lw=3)

    speeds=[] #holds max speed for each segment
    lengths=[] #holds length of each segment
    entity_list = track_tuple[0]
    reverse = track_tuple[1]

    #we're going to iterate through all the entites (a line or arc) in the dxf and calculate their lengths and max speeds
    sector_start_indices = []
    n_corners = 0
    for i in range(len(entity_list)):
        entity=entity_list[i]
        if entity.dxftype()=='LINE':
            vmax=90 #no upper limit on speed on straights (this is like 200mph so way above what car can do) - (TS) may want modify based on motor max RPM
            segment_length=np.linalg.norm([entity.dxf.end[0]-entity.dxf.start[0],entity.dxf.end[1]-entity.dxf.start[1]])
            lengths.append(segment_length)
            speeds.append(vmax)

        if entity.dxftype() =='ARC':
            if verbose:
                if n_corners%sector_corners == 0:
                    sector_start_indices.append(i)
                n_corners+=1
            r_turn = entity.dxf.radius
            grip_limit_v = car.cornering_speed(r_turn)
            speeds.append(grip_limit_v)

            segment_length = entity.dxf.radius*((entity.dxf.end_angle-entity.dxf.start_angle)%360)*np.pi/180
            lengths.append(segment_length)
            
            
    #now iterate through each segment and calculate car speeds etc
    total_time = 0
    #we need to start at the end of the slowest segment of the track so as to have a defined  start velocity for the first segment
    v_end = np.zeros(len(speeds)) #this holds the car speed at the end of each segment
    i_start=np.argmin(speeds)+1 # this is the index of the segment after the slowest one
    v_end[i_start-1]=speeds[i_start-1] #end velocity for the zero'th segment is the limit for that segment because it is the slowest on the circuit
    sector_counter = 0

    #(TS) Generates blank arrays to store velocities and displacements - appended in the for loop iterating over each segment
    v_full = np.array([])
    x_full = np.array([])
    power_full = np.array([])
    time_full = np.array([])
    rpm_full = np.array([])
    #Instantaneous current draw from Accumulator
    instant_current = np.array([])

    for i in range(i_start,len(speeds)+i_start):
        x_segment = np.linspace(0,lengths[i%len(speeds)],100) # this is the array of x for the segment - (TS) i%len(speeds) modulo to jump back to correct sector
        v_lim = speeds[i%len(speeds)]*np.ones(len(x_segment)) # velocity limit for this segment (TS)(sets the maximum speed to every point along the segment)
        v_list = [v_lim] # this will be the list of limiting velocities, velocity is the element-wise minimum of this list
        
        #if the previous segment limiting velocity or end velocity is less than the limit for this segment, accelerate from that speed
        
        #(TS) Too sharp of a torque drop off screws up the minimum velocity finding block in each track sector 
        try:
            if np.min([speeds[(i-1)%len(speeds)],v_end[(i-1)%len(speeds)]]) < speeds[i%len(speeds)]:
                target_v0 = np.min([speeds[(i-1)%len(speeds)],v_end[(i-1)%len(speeds)]])
                x1 = car.accel_v_inv(target_v0) # what x-position on the acceleration curve is our start velocity (TS) Target speed - exit speed of prev corner, returns target position from acceleration curve
                v_accel = car.accel_v(x_segment+x1) # acceleration velocity is just the acceleration curve, starting from x1
                v_list.append(v_accel)  
        
        except ValueError:
            print("Issue in this block")


        #if the next segment's limiting velocity is less than the limit for this segment, brake down to that speed
        if speeds[(i+1)%len(speeds)] < speeds[i%len(speeds)]:
            target_v1 = speeds[(i+1)%len(speeds)]
            x1 = car.brake_v_inv(target_v1) #what x position on the braking curve is our end velocity
            v_brake = car.brake_v(x_segment+(x1-lengths[i%len(speeds)])) # braking velocity is the braking curve, shifted by x1
            v_list.append(v_brake)
        #the velocity at any point in the segment is the element-wise minimum of everything in v_list
        if len(v_list)==1:
            v_segment = v_list[0]
        if len(v_list)==2:
            v_segment = np.minimum(v_list[0],v_list[1])   #Straight into corner - so does not consider acceleration curve, might be 1 long etc... (ignores recalculation)
        if len(v_list)==3:
            v_segment = np.minimum(np.minimum(v_list[0],v_list[1]),v_list[2])
        

        
        #(TS) v_segment - list of segment velocities. This list is joined and updates the overall list of velocities
        v_full = np.concatenate((v_full, v_segment)) #(TS) adds the current velocity
        #(TS) Keeps track of current position relative to start of segment. x_segment is the distance to the nth (current) segment. This adds length of n-1 th segment.
        x_current = (np.sum(lengths[:i%len(speeds)])-np.sum(lengths[:i_start]))%np.sum(lengths) 
        x_full = np.concatenate((x_full, x_current+x_segment)) #Updates full list of displacements  

        #Instantaneous power use - extrapolating from intepolator function based on current rpm and engine data
        for n, current_vel in enumerate(v_segment):
            #Note: in IC, this misleadingly only gives power when operating in first gear - actual value depends on which gear we are in            
            rpm = current_vel*car.powertrain.ratios[0]*60/(2*np.pi*0.2445)   #[0] index 0 corresponds to first gear (constant drive ratio for EV)
            
            if car.powertrain.ic == True:
                if rpm >= 5000 and rpm <= car.powertrain.max_rpm:
                    power = car.powertrain.f_power(rpm)
                elif rpm > car.powertrain.max_rpm:
                    power = car.powertrain.f_power(car.powertrain.max_rpm)    
                else:  #If <5000 RPM assume driver is riding the clutch, and RPM maintained by throttle
                    power = car.powertrain.f_power(5000)
            
            elif car.powertrain.ic == False:
                if rpm >= car.powertrain.max_rpm:
                    power = car.powertrain.f_power(car.powertrain.max_rpm)
                elif rpm < car.powertrain.min_rpm:
                    power = 0 #Stationary rotor means motor not getting any input power    
                else:  
                    power = car.powertrain.f_power(rpm)
            #Appending to total list of powers (against RPM)

            """Use power values to get a profile of voltage over time - current limit will set the voltage"""
        
            power_full = np.append(power_full, power)  #Value by value list accumulation - instead of 'list' concatenations
            rpm_full = np.append(rpm_full, rpm) #RPM checking to see if we ever exit knee-point torque/ power (rpm @ curve kink)
            
            
            if current_vel - v_segment[n-1] < 0: #If braking - then current 'sense' relative to Accumulator terminals is negative (NOTE: current through windings remains positive)
                instant_current = np.append(instant_current, -1*power/((car.powertrain.T_max/I_rms)*2*np.pi*rpm/60)) #Power / w = Torque, where Torque = k*phi*I_applied
            else:
                instant_current = np.append(instant_current, power/((car.powertrain.T_max/I_rms)*2*np.pi*rpm/60))             

        v_end[i%len(speeds)]=v_segment[-1]
        
        #this does an integration to get time elapsed from the start of the segment at every x position in x_segment (TS) can just use average speed of each segment to find the time 
        t=np.zeros(len(x_segment))
        for j in range(1,len(x_segment)):
            t[j] = t[j-1] + 2/(v_segment[j-1]+v_segment[j])*(x_segment[j]-x_segment[j-1])
        segment_time=t
        
        #Sums time increments for each segment into an array for net lap time. NOTE: time_full is different to 'total_time' (which is time taken to complete each segment)
        time_full = np.concatenate((time_full, total_time+segment_time)) 
        total_time += segment_time[-1]
                  

        if verbose: 
            x_current = (np.sum(lengths[:i%len(speeds)])-np.sum(lengths[:i_start]))%np.sum(lengths) #(TS) keeps track of the current position
            for v in v_list:
                ax[0].plot(x_segment+x_current,v, '--') #this plots all the limits for this segment in dashed lines
            ax[0].plot(x_segment+x_current,v_segment) #this plots the car velocity for this segment
            ax[1].plot(segment_time+total_time-segment_time[-1],v_segment)

            #sector markers
            if i%len(speeds) in sector_start_indices:
                sector_counter+=1
                ax[0].axvline(x_current, color='black')
                ax[0].text(x_current, 90, 'End Sector {}'.format(sector_counter), rotation='vertical', verticalalignment='top', horizontalalignment='right')
                ax[1].axvline(total_time-segment_time[-1], color='black', label='Sector {}'.format(np.argmin(np.array(sector_start_indices)-i%len(speeds))+1))
                ax[1].text(total_time-segment_time[-1], 30, 'End Sector {}'.format(sector_counter), rotation='vertical', verticalalignment='top', horizontalalignment='right')

            #map plot
            entity = entity_list[i%len(speeds)]
            if entity.dxftype()=='ARC':
                center = np.array((entity.dxfattribs()['center'][0],entity.dxfattribs()['center'][1]))
                r = entity.dxfattribs()['radius']
                if entity.dxfattribs()['start_angle']<entity.dxfattribs()['end_angle']:
                    theta = np.linspace(entity.dxfattribs()['start_angle'],entity.dxfattribs()['end_angle'],len(x_segment))*np.pi/180
                else:
                    theta = np.linspace(entity.dxfattribs()['start_angle'],entity.dxfattribs()['end_angle']+360,len(x_segment))*np.pi/180
                if reverse[i%len(speeds)]:
                    theta = np.flip(theta)
                xmap = center[0]+r*np.cos(theta)
                ymap = center[1]+r*np.sin(theta)
            else:
                start = np.array((entity.dxfattribs()['start'][0],entity.dxfattribs()['start'][1]))
                end = np.array((entity.dxfattribs()['end'][0],entity.dxfattribs()['end'][1]))
                xmap = np.linspace(start[0],end[0],len(x_segment))
                ymap = np.linspace(start[1],end[1],len(x_segment))
            
            #Sector and start/finish markers
            if i == i_start:
                ax[2].plot(xmap[0],ymap[0],'x', color='black')
                ax[2].text(xmap[0],ymap[0], 'Start/Finish', verticalalignment='top', horizontalalignment='right')
            
            if i%len(speeds) in sector_start_indices:
                ax[2].plot(xmap[0],ymap[0],'x', color='black')
                ax[2].text(xmap[0],ymap[0], 'End S{}'.format(sector_counter), verticalalignment='top', horizontalalignment='right')
            
            colorplot(ax[2],xmap,ymap,v_segment,vmin=0,vmax=35)

    if verbose:
        ax[0].set(xlabel='Distance/m', ylabel='Velocity /ms^-1', title='Total Time={}s'.format(np.round(total_time,2)))
        ax[1].set(xlabel='Time / s', ylabel='Velocity / ms^-1')
        ax[2].set(aspect='equal', title='Track map')
        sm = plt.cm.ScalarMappable(cmap=mpl.colormaps['jet'], norm = mpl.colors.Normalize(vmin=0,vmax=35))
        sm.set_array([])
        plt.colorbar(sm, ticks=np.linspace(0, 35, 11),label='Velocity / ms^-1', ax = ax[2])
        plt.show()
    

        #2nd set of plots display Duty-cycle of the car over total lap_duration
        fig, (ax1, ax3) = plt.subplots(2,1, sharex = True)
    
        ax1.set_xlabel('Time (s)')
        ax1.set_ylabel('Velocity (m/s)', color= 'red')
        ax1.plot(time_full, v_full, color='red')
        #ax1.plot(x_full, v_full, color='red') #Instead of time varying duty cycle - displacement varying duty cycle 
        ax1.tick_params(axis='y', labelcolor= 'red')

        # Create a second y-axis sharing the same x-axis
        ax2 = ax1.twinx()
    
        ax2.set_xlabel('Time (s)')
        ax2.set_ylabel('Power draw (kW)', color= 'green')
        ax2.plot(time_full, power_full/1000, color='green')
        ax2.tick_params(axis='y', labelcolor= 'green')


        ax3.set_xlabel('Time (s)')
        ax3.set_ylabel('Current Draw (A)', color= 'blue')
        ax3.scatter(time_full, instant_current, color='blue', s = 1)
        ax3.tick_params(axis='y', labelcolor= 'blue')
     

        plt.title("Duty cycle of vehicle comparing Velocity and Power plots over lap-time elapsed.")
        plt.show()
        
    #Total energy consumption: integration of instantaneous power with timesteps:    
    energy = 0
    for p, t0, t in zip(power_full[:-1], time_full[:-1], time_full[1:]):
        energy += p*(t-t0)
        
    return total_time, energy




def compare_cars(track_tuple, car, ref_car):
    '''Compares 2 cars' laps around track_tuple. Works almost exactly the same as process_track()'''
    sector_corners = 6 #number of corners in a sector

    fig = plt.figure(figsize=(9,6))
    fig.set_tight_layout(True)
    ax=[]
    ax.append(fig.add_subplot(221))
    ax.append(fig.add_subplot(223))
    ax.append(fig.add_subplot(122))

    def colorplot(ax, x, y, c, cmap_name='turbo', vmin=0, vmax=1):
        '''plot a line on axis ax with colour along line colourmapped to array c'''
        cmap=mpl.colormaps[cmap_name]
        norm = mpl.colors.Normalize(vmin=vmin,vmax=vmax)
        for i in range(len(x)-1):
            ax.plot([x[i],x[i+1]],[y[i],y[i+1]],c=cmap(norm(0.5*(c[i]+c[i+1]))), lw=3)
    
    speeds=[] #holds max speed for each segment
    ref_speeds = []
    lengths=[] #holds length of each segment
    entity_list = track_tuple[0]
    reverse = track_tuple[1]

    sector_start_indices = []
    n_corners = 0
    #we're going to iterate through all the entites (a line or arc) in the dxf and calculate their lengths and max speeds
    for i in range(len(entity_list)):
        entity=entity_list[i]
        if entity.dxftype()=='LINE':
            vmax=90 #no upper limit on speed on straights (this is like 200mph so way above what car can do)
            segment_length=np.linalg.norm([entity.dxf.end[0]-entity.dxf.start[0],entity.dxf.end[1]-entity.dxf.start[1]])
            lengths.append(segment_length)
            speeds.append(vmax)
            ref_speeds.append(vmax)

        if entity.dxftype() =='ARC':
            if n_corners%sector_corners == 0:
                sector_start_indices.append(i)
            n_corners+=1

            r_turn = entity.dxf.radius
            grip_limit_v = car.cornering_speed(r_turn)
            speeds.append(grip_limit_v)

            grip_limit_v = ref_car.cornering_speed(r_turn)
            ref_speeds.append(grip_limit_v)

            segment_length = entity.dxf.radius*((entity.dxf.end_angle-entity.dxf.start_angle)%360)*np.pi/180
            lengths.append(segment_length)

    #now iterate through each segment and calculate car speeds etc
    total_time = 0
    total_time_ref = 0
    #we need to start at the end of the slowest segment of the track so as to have a defined  start velocity for the first segment
    v_end = np.zeros(len(speeds)) #this holds the car speed at the end of each segment
    v_end_ref = np.zeros(len(speeds))
    i_start=np.argmin(speeds)+1 # this is the index of the segment after the slowest one
    v_end[i_start-1]=speeds[i_start-1] #end velocity for the zero'th segment is the limit for that segment because it is the slowest on the circuit
    v_end_ref[i_start-1]=ref_speeds[i_start-1]
    sector_counter=0

    for i in range(i_start,len(speeds)+i_start):
        x_segment = np.linspace(0,lengths[i%len(speeds)],100) # this is the array of x for the segment
        v_lim = speeds[i%len(speeds)]*np.ones(len(x_segment)) # velocity limit for this segment
        v_lim_ref = ref_speeds[i%len(ref_speeds)]*np.ones(len(x_segment))
        v_list_ref = [v_lim_ref]
        v_list = [v_lim] # this will be the list of limiting velocities, velocity is the element-wise minimum of this list
        
        #if the previous segment limiting velocity or end velocity is less than the limit for this segment, accelerate from that speed
        if np.min([speeds[(i-1)%len(speeds)],v_end[(i-1)%len(speeds)]]) < speeds[i%len(speeds)]:
            target_v0 = np.min([speeds[(i-1)%len(speeds)],v_end[(i-1)%len(speeds)]])
            x1 = car.accel_v_inv(target_v0) # what x-position on the acceleration curve is our start velocity
            v_accel = car.accel_v(x_segment+x1) # acceleration velocity is just the acceleration curve, starting from x1
            v_list.append(v_accel)

        if np.min([ref_speeds[(i-1)%len(ref_speeds)],v_end_ref[(i-1)%len(ref_speeds)]]) < ref_speeds[i%len(ref_speeds)]:
            target_v0 = np.min([ref_speeds[(i-1)%len(ref_speeds)],v_end_ref[(i-1)%len(ref_speeds)]])
            x1 = ref_car.accel_v_inv(target_v0) # what x-position on the acceleration curve is our start velocity
            v_accel = ref_car.accel_v(x_segment+x1) # acceleration velocity is just the acceleration curve, starting from x1
            v_list_ref.append(v_accel)
        
        #if the next segment's limiting velocity is less than the limit for this segment, brake down to that speed
        if speeds[(i+1)%len(speeds)] < speeds[i%len(speeds)]:
            target_v1 = speeds[(i+1)%len(speeds)]
            x1 = car.brake_v_inv(target_v1) #what x position on the braking curve is our end velocity
            v_brake = car.brake_v(x_segment+(x1-lengths[i%len(speeds)])) # braking velocity is the braking curve, shifted by x1
            v_list.append(v_brake)

        if ref_speeds[(i+1)%len(ref_speeds)] < ref_speeds[i%len(ref_speeds)]:
            target_v1 = ref_speeds[(i+1)%len(ref_speeds)]
            x1 = ref_car.brake_v_inv(target_v1) #what x position on the braking curve is our end velocity
            v_brake = ref_car.brake_v(x_segment+(x1-lengths[i%len(ref_speeds)])) # braking velocity is the braking curve, shifted by x1
            v_list_ref.append(v_brake)

        #the velocity at any point in the segment is the element-wise minimum of everything in v_list
        if len(v_list)==1:
            v_segment = v_list[0]
        if len(v_list)==2:
            v_segment = np.minimum(v_list[0],v_list[1])
        if len(v_list)==3:
            v_segment = np.minimum(np.minimum(v_list[0],v_list[1]),v_list[2]) #Compares set of 2, then following set of minima

        if len(v_list_ref)==1:
            v_segment_ref = v_list_ref[0]
        if len(v_list_ref)==2:
            v_segment_ref = np.minimum(v_list_ref[0],v_list_ref[1])
        if len(v_list_ref)==3:
            v_segment_ref = np.minimum(np.minimum(v_list_ref[0],v_list_ref[1]),v_list_ref[2])

        v_end[i%len(speeds)]=v_segment[-1]
        v_end_ref[i%len(ref_speeds)]=v_segment_ref[-1]

        #this does an integration to get time elapsed from the start of the segment at every x position in x_segment
        t=np.zeros(len(x_segment))
        for j in range(1,len(x_segment)):
            t[j] = t[j-1] + 2/(v_segment[j-1]+v_segment[j])*(x_segment[j]-x_segment[j-1])
        segment_time=t
        total_time += segment_time[-1]

        t_ref=np.zeros(len(x_segment))
        for j in range(1,len(x_segment)):
            t_ref[j] = t_ref[j-1] + 2/(v_segment_ref[j-1]+v_segment_ref[j])*(x_segment[j]-x_segment[j-1])
        segment_time_ref=t_ref
        total_time_ref += segment_time_ref[-1]

        #Plotting
        x_current = (np.sum(lengths[:i%len(speeds)])-np.sum(lengths[:i_start]))%np.sum(lengths)
        ax[0].plot(x_segment+x_current,v_segment) #this plots the car velocity for this segment
        ax[0].plot(x_segment+x_current,v_segment_ref,'--') #this plots the car velocity for this segment
        ax[1].plot(segment_time+total_time-segment_time[-1],v_segment)
        ax[1].plot(segment_time_ref+total_time_ref-segment_time_ref[-1],v_segment_ref,'--')

        #Sector markings
        if i%len(speeds) in sector_start_indices:
            sector_counter+=1
            ax[0].axvline(x_current, color='black')
            ax[0].text(x_current, 30, 'End Sector {}'.format(sector_counter), rotation='vertical', verticalalignment='top', horizontalalignment='right')
            ax[1].axvline(total_time-segment_time[-1], color='black', label='Sector {}'.format(np.argmin(np.array(sector_start_indices)-i%len(speeds))+1))
            ax[1].text(total_time-segment_time[-1], 30, 'End Sector {}'.format(sector_counter), rotation='vertical', verticalalignment='top', horizontalalignment='right')


        #map plot
        entity = entity_list[i%len(speeds)]
        if entity.dxftype()=='ARC':
            center = np.array((entity.dxfattribs()['center'][0],entity.dxfattribs()['center'][1]))
            r = entity.dxfattribs()['radius']
            if entity.dxfattribs()['start_angle']<entity.dxfattribs()['end_angle']:
                theta = np.linspace(entity.dxfattribs()['start_angle'],entity.dxfattribs()['end_angle'],len(x_segment))*np.pi/180
            else:
                theta = np.linspace(entity.dxfattribs()['start_angle'],entity.dxfattribs()['end_angle']+360,len(x_segment))*np.pi/180
            if reverse[i%len(speeds)]:
                theta = np.flip(theta)

            xmap = center[0]+r*np.cos(theta)
            ymap = center[1]+r*np.sin(theta)
        else:
            start = np.array((entity.dxfattribs()['start'][0],entity.dxfattribs()['start'][1]))
            end = np.array((entity.dxfattribs()['end'][0],entity.dxfattribs()['end'][1]))

            xmap = np.linspace(start[0],end[0],len(x_segment))
            ymap = np.linspace(start[1],end[1],len(x_segment))

        #Sector and start/finish markers
        if i == i_start:
            ax[2].plot(xmap[0],ymap[0],'x', color='black')
            ax[2].text(xmap[0],ymap[0], 'Start/Finish', verticalalignment='top', horizontalalignment='right')
            
        if i%len(speeds) in sector_start_indices:
            ax[2].plot(xmap[0],ymap[0],'x', color='black')
            ax[2].text(xmap[0],ymap[0], 'End S{}'.format(sector_counter), verticalalignment='top', horizontalalignment='right')
        
        colorplot(ax[2],xmap,ymap,v_segment-v_segment_ref,vmin=-5,vmax=5,cmap_name='seismic')

    #axis titles etc
    if verbose:
        ax[0].set(xlabel='Distance/m', ylabel='Velocity /ms^-1', title='Total Time Difference= {} s'.format(np.round(total_time-total_time_ref,3)))
        ax[1].set(xlabel='Time / s', ylabel='Velocity / ms^-1')
        ax[2].set(aspect='equal', title='Track map')
        ax[2].set_facecolor('grey')
        sm = plt.cm.ScalarMappable(cmap=mpl.colormaps['seismic'], norm = mpl.colors.Normalize(vmin=-5,vmax=5))
        sm.set_array([])
        plt.colorbar(sm, ticks=np.linspace(-5, 5, 11),label='Velocity / ms^-1', ax = ax[2])
        fig.suptitle('Comparing FBR23 against FBR20', fontsize=16)
        plt.show()

    return total_time

def skidpad(car):
    '''simulates skidpad event. super simple'''
    r_turn = 8.5 #m, allowing 125mm to inner cones
    grip_limit_v = car.cornering_speed(r_turn)
    t = 2*np.pi*r_turn/grip_limit_v #1 full turn, this assumes left turn and right turn are identical in speed
    return t

def acceleration(car):
    '''simulates acceleration event. super simple'''
    x = np.linspace(0,75,100)
    dx = x[1]
    t=np.zeros(len(x))
    for i in range(1,len(x)):
        t[i] = t[i-1] + 2/(car.accel_v(x[i-1])+car.accel_v(x[i]))*dx
    return t[-1]

def practice_integration():
    '''A little check to see if the numerical integrators used throughout are good enough. They are :)'''
    FBR23 = CarData.car()
    max_P = np.max(FBR23.powertrain.f_power(np.linspace(FBR23.powertrain.min_rpm,FBR23.powertrain.max_rpm,30)))
    x_max=75
    x = np.linspace(0,x_max,100)
    dx = x[1]-x[0]
    v=np.zeros(len(x))
    v[0]=0
    #aero properties
    def accel(v):
        if v == 0: 
            return FBR23.mu*9.81
        else:
            if max_P/(v*FBR23.m) > FBR23.mu*9.81: return FBR23.mu*9.81
            else:
                return max_P/(v*FBR23.m)
    for i in range(1,len(x)):
        v[i] = np.sqrt(v[i-1]**2 + 2*dx*accel(v[i-1]))

    #true solution
    v1 = max_P/(FBR23.m*FBR23.mu*9.81)
    x1 = v1**2/(2*FBR23.mu*9.81)
    x_true1 = np.linspace(0,x1,100)
    v_true1 = np.sqrt(2*FBR23.mu*9.81*x_true1)
    x_true2 = np.linspace(x1,300,100)
    v_true2 = (3*(x_true2-x1)*max_P/FBR23.m+v1**3)**(1/3)
    
    #integral solution
    t=np.zeros(len(x))
    for i in range(1,len(x)):
        t[i] = t[i-1] + 2/(v[i-1]+v[i])*dx
    #true solution
    t_true=np.sqrt(2*(x_max)/(FBR23.mu*9.81))

    plt.plot(x,v)
    plt.plot(x_true1,v_true1)
    plt.plot(x_true2, v_true2)

    plt.show()
    plt.plot(t,x)
    plt.title('Time = {}'.format(t[-1]))
    plt.show()

'''Sensitivity functions - seeing how simulation outputs vary with car parameters'''

def gear_change(car):
    '''Prints the car speed in mph in all the gears at a given rpm'''
    target_rpm =3000
    v = [target_rpm/G*0.2445 * 4/9 for G in car.powertrain.ratios]
    print('At {}rpm and Final Drive = {}:'.format(target_rpm,car.powertrain.final_drive))
    for i in range(len(v)):
        print('Gear {} : {}mph'.format(i+1,v[i]))
    return 0

def acceleration_sensitivity():
    '''Create a heatmap of acceleration event time against car mass and downforce'''
    FBR23 = CarData.car()
    print('running')

    downforce = np.linspace(0,200,30)
    mass = np.linspace(220,400,30)

    #we're going to iterate over both of these in a grid and see how it affects acceleration time
    M,D = np.meshgrid(mass, downforce)
    T = np.zeros(np.shape(D))
    for i in range(len(downforce)):
        for j in range(len(mass)):
            FBR23.k_df = downforce[i]*9.81/(0.5*1.225*25**2)
            FBR23.m=mass[j]
            FBR23.update()
            
            T[i,j]=acceleration(FBR23)

    time = plt.contour(D,M,T, levels=50)
    plt.plot(0,310, 'x')
    plt.colorbar(time, label='Acceleration Time / s')
    plt.xlabel('Downforce @25m/s (kg)')
    plt.ylabel('Car mass (kg)')
    plt.title('Acceleration Time')
    plt.show()

def skidpad_sensitivity():
    '''Create a heatmap of skidpad event time against car mass and downforce'''
    print('running')

    FBR23 = CarData.car()

    downforce = np.linspace(0,200,30)
    mass = np.linspace(220,400,30)

    #we're going to iterate over both of these in a grid and see how it affects acceleration time
    M,D = np.meshgrid(mass, downforce)
    T = np.zeros(np.shape(D))
    for i in range(len(downforce)):
        for j in range(len(mass)):
            FBR23.k_df = downforce[i]*9.81/(0.5*1.225*25**2)
            FBR23.m=mass[j]
            FBR23.update()
            T[i,j]=skidpad(FBR23)

    time = plt.contour(D,M,T, levels=50)
    plt.plot(0,310, 'x')
    #cax = plt.axes([0.85, 0.1, 0.075, 0.8])
    plt.colorbar(time, label='Skidpad Time / s')
    plt.xlabel('Downforce @25m/s (kg)')
    plt.ylabel('Car mass (kg')
    plt.title('Skidpad Time')
    plt.show()

def sprint_sensitivity():
    '''Create a heatmap of sptint event time against car mass and downforce'''
    print('running')

    FBR23 = CarData.car()
    track = read_track('FSA Track.dxf')

    downforce = np.linspace(0,200,30)
    mass = np.linspace(220,400,30)

    #we're going to iterate over both of these in a grid and see how it affects acceleration time
    M,D = np.meshgrid(mass, downforce)
    T = np.zeros(np.shape(D))
    for i in range(len(downforce)):
        for j in range(len(mass)):
            FBR23.k_df = downforce[i]*9.81/(0.5*1.225*25**2)
            FBR23.m=mass[j]
            FBR23.update()
            T[i,j]=process_track(track, FBR23)

    time = plt.contour(D,M,T, levels=50)
    plt.plot(0,310, 'x')
    #cax = plt.axes([0.85, 0.1, 0.075, 0.8])
    plt.colorbar(time, label='Sprint Time / s')
    plt.xlabel('Downforce @25m/s (kg)')
    plt.ylabel('Car mass (kg')
    plt.title('Sprint Time')
    plt.show()

def points_sensitivity():
    '''Create a heatmap of total dynamic event points against car mass and downforce'''
    print('running')
    track_tuple = read_track('FSA Track.dxf')

    #Reasonable winning car - think like karlsruhe
    fast_car = CarData.car()
    fast_car.m = 220
    fast_car.k_df = 200*9.81/(0.5*1.225*25**2)
    fast_car.powertrain.shift_time=0.15
    fast_car.update()

    fastest_skid = skidpad(fast_car)
    fastest_accel = acceleration(fast_car)
    fastest_sprint = process_track(track_tuple,fast_car)

    FBR23 = CarData.car()
    FBR23.powertrain.shift_time=0

    downforce = np.linspace(0,200,30)
    mass = np.linspace(150,400,30)

    #we're going to iterate over both of these in a grid and see how it affects points
    print('Iteration started')
    M,D = np.meshgrid(mass, downforce)
    P = np.zeros(np.shape(D))
    for i in range(len(downforce)):
        for j in range(len(mass)):
            FBR23.k_df = downforce[i]*9.81/(0.5*1.225*25**2)
            FBR23.m=mass[j]
            FBR23.update()

            skid_time=skidpad(FBR23)
            accel_time=acceleration(FBR23)
            sprint_time = process_track(track_tuple, FBR23)

            #These equations are defined in the FSUK Regs, under dynamic events
            skid_points = 5 + 70*((fastest_skid*1.25/skid_time)**2-1)/((1.25)**2-1)          
            accel_points = 5 + 65*((fastest_accel*1.5/accel_time)-1)/((1.5)-1)
            sprint_points = 5 + 95*((fastest_sprint*1.45/sprint_time)-1)/(1.45-1)
            endurance_points = 25 + 225*((fastest_sprint*1.45/sprint_time)-1)/(1.45-1)

            P[i,j]=skid_points+accel_points + sprint_points + endurance_points

    points = plt.contour(D,M,P, levels=50)
    plt.plot(0,310, 'x', label='FBR20')
    plt.plot(100,325,'x',label='FBR23')

    #Labelling of everything
    def fmt(x):
        s = f"{x:.1f}"
        if s.endswith("0"):
            s = f"{x:.0f}"
        return rf"{s} \%" if plt.rcParams["text.usetex"] else f"{s}"

    plt.clabel(points, inline=True, fmt=fmt, fontsize=10)
    plt.colorbar(points, label='Total Dynamic Event Points except efficiency')
    plt.xlabel('Downforce @25m/s (kg)')
    plt.ylabel('Car mass (kg')
    plt.title('Total Dynamic Event Points except efficiency')
    plt.legend()
    plt.show()
    
def shift_time_sensitivity():
    '''Plots graphs of accel event time, sprint lap time and total points against shift time'''
    track_tuple = read_track('FSA Track.dxf')

    fast_car = CarData.car()
    fast_car.m = 220
    fast_car.k_df = 200*9.81/(0.5*1.225*25**2)
    fast_car.powertrain.shift_time=0.15
    fast_car.update()

    fastest_skid = skidpad(fast_car)
    fastest_accel = acceleration(fast_car)
    fastest_sprint = process_track(track_tuple,fast_car)

    FBR23 = CarData.car()

    t_list = np.linspace(0,1,10)
    points = []
    accel_times = []
    sprint_times=[]

    for t in t_list:
        FBR23.powertrain.shift_time=t
        FBR23.update()

        skid_time=skidpad(FBR23)
        accel_time=acceleration(FBR23)
        accel_times.append(accel_time)
        sprint_time = process_track(track_tuple, FBR23)
        sprint_times.append(sprint_time)

        skid_points = 5 + 70*((fastest_skid*1.25/skid_time)**2-1)/((1.25)**2-1)          
        accel_points = 5 + 65*((fastest_accel*1.5/accel_time)-1)/((1.5)-1)
        sprint_points = 5 + 95*((fastest_sprint*1.45/sprint_time)-1)/(1.45-1)
        endurance_points = 25 + 225*((fastest_sprint*1.45/sprint_time)-1)/(1.45-1)

        points.append(skid_points+accel_points+sprint_points+endurance_points)
    
    #Plotting
    fig = plt.figure()
    fig.set_tight_layout(True)
    ax=[]
    ax.append(fig.add_subplot(221))
    ax.append(fig.add_subplot(223))
    ax.append(fig.add_subplot(122))
    ax[0].plot(t_list,accel_times)
    ax[2].plot(t_list,points)
    ax[1].plot(t_list,sprint_times)
    ax[1].set(xlabel='Shift time / s', ylabel ='Sprint lap time / s', title='Sprint time variation with shift time')
    ax[0].set(xlabel='Shift time / s', ylabel='Acceleration time / s', title='Acceleration time variation with shift time')
    ax[2].set(xlabel='Shift time / s', ylabel='Total dynamic event points except efficiency', title='Points variation with shift time')
    plt.show()

def final_drive_sensitivity():
    '''Plots graphs of accel event time, sprint lap time and total points against final drive ratio for several shift times'''
    print('running')
    track_tuple = read_track('FSA Track.dxf')

    fig = plt.figure()
    fig.set_tight_layout(True)
    ax=[]
    ax.append(fig.add_subplot(221))
    ax.append(fig.add_subplot(223))
    ax.append(fig.add_subplot(122))

    fast_car = CarData.car()
    fast_car.m = 220
    fast_car.k_df = 200*9.81/(0.5*1.225*25**2)
    fast_car.powertrain.shift_time=0.15
    fast_car.update()

    fastest_skid = skidpad(fast_car)
    fastest_accel = acceleration(fast_car)
    fastest_sprint = process_track(track_tuple,fast_car)

    FBR23 = CarData.car()
    #FBR23.k_df=0

    t_list = np.linspace(0.2,0.5,4)
    ratio_list = np.linspace(2,5,50)
    
    for t in t_list:
        points = []
        accel_times = []
        sprint_times=[]
        for r in ratio_list:
            FBR23.powertrain.shift_time=t
            FBR23.powertrain.final_drive=r
            FBR23.powertrain.update()
            FBR23.update()

            skid_time=skidpad(FBR23)
            accel_time=acceleration(FBR23)
            accel_times.append(accel_time)
            sprint_time = process_track(track_tuple, FBR23)
            sprint_times.append(sprint_time)

            skid_points = 5 + 70*((fastest_skid*1.25/skid_time)**2-1)/((1.25)**2-1)          
            accel_points = 5 + 65*((fastest_accel*1.5/accel_time)-1)/((1.5)-1)
            sprint_points = 5 + 95*((fastest_sprint*1.45/sprint_time)-1)/(1.45-1)
            endurance_points = 25 + 225*((fastest_sprint*1.45/sprint_time)-1)/(1.45-1)

            points.append(skid_points+accel_points+sprint_points+endurance_points)
        
        ax[0].plot(ratio_list,accel_times, label='Shift time: {}s'.format(t))
        ax[2].plot(ratio_list,points, label='Shift time: {}s'.format(t))
        ax[1].plot(ratio_list,sprint_times, label='Shift time: {}s'.format(t))
    for a in ax:
        a.legend()
    ax[1].set(xlabel='Final drive ratio', ylabel ='Sprint lap time / s', title='Sprint time variation with shift time')
    ax[0].set(xlabel='Final drive ratio', ylabel='Acceleration time / s', title='Acceleration time variation with shift time')
    ax[2].set(xlabel='Final drive ratio', ylabel='Total dynamic event points except efficiency', title='Points variation with shift time')
    plt.show()

'''Sample code to do different things: uncomment things to run them'''

#write_track()

#acceleration_sensitivity()
#skidpad_sensitivity()
#sprint_sensitivity()
#points_sensitivity()
#shift_time_sensitivity()
#final_drive_sensitivity()

#_____ This block compares the FBR20 to a reasonable guess of the FBR23 with aero and paddle shift.
FBR20 = CarData.car()
FBR20.k_df=0
FBR20.update()

FBR23 = CarData.car()
FBR23.m=330 #20kg of aero kit and paddle shift
FBR23.powertrain.final_drive=3
FBR23.powertrain.shift_time=0.2

FBR23.powertrain.ratios_0 = [16.06, 12.44, 10.39, 8.98, 8] #(TS) R6 engine Gear Ratios - last updated by Aidan 22/23 

FBR23.powertrain.ic = True

FBR23.powertrain.update()
FBR23.update()


#______ This block generates the FBRev - with identical characteristics to the FBR23 drive train except:
#1. Replacing engine P/T curves with Motor   2. Single applied gear ratio
FBRev = CarData.car()
FBRev.m=340 #25 kg Aero kit + 15 kg surplus electronics

#Key parameter changes for EV - final_drive bypasses R6 gearbox ratios
FBRev.powertrain.final_drive = 12
"""Rear gear teeth/ front gear teeth: currently approx. 31/ 11, wants to be higher for greater torque"""
FBRev.powertrain.ic = False
gear_ratios = [1] #Even if single gear ratio, must be entered as an array


#Verfication to check geometry of torque and power curves
def tp_curve_check(car):
    rpm_values = np.linspace(car.powertrain.min_rpm,car.powertrain.max_rpm, 1000)
    power_y = FBR27.powertrain.f_power(rpm_values)
    torque_y = FBR27.powertrain.f_torque(rpm_values)
    plt.plot(rpm_values, power_y/1000, '-', rpm_values, torque_y, '-')
    plt.show()

#tp_curve_check(FBR27)

fastest_time = 1000 #Arbitrarily high lap-time: impossible

for n, motor in enumerate(motors_list, 1):
    FBRev.powertrain.engine_data = f"Motor{n}.csv"  
    FBRev.powertrain.update() #Updates file reading
    FBRev.update()
    time = process_track(read_track('FSA Track.dxf'),FBRev, verbose=False)[0]
    
    if time < fastest_time:
        fastest_time = time
        best_motor = n #nth motor - required for auto-generating the track performance for the fastest motor

FBRev.powertrain.engine_data = f"Motor{best_motor}.csv"  
FBRev.powertrain.update() #Updates file reading
FBRev.update()

print("Best motor is: {} with a lap-time of: {:.2f}s.\n Total energy consumption: {:.2f} MJ".format(best_motor, fastest_time, process_track(read_track('FSA Track.dxf'),FBRev, verbose=False)[1]/(1e6)))
process_track(read_track('FSA Track.dxf'),FBRev, verbose=True)
    

#compare_cars(read_track('FSA Track.dxf'),FBR23,FBR27)
#FBR23.acceleration(verbose=True)
#FBR20.acceleration(verbose=True)

